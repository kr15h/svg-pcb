import { changeDpiDataUrl } from "./changeDPI.js";
import { offset2 } from "../../geogram/index.js";
import JSZip from "jszip";
import { saveAs } from "file-saver";
import { global_state } from "../global_state.js";

function toMM(inches){
    return inches * global_state.mm_per_unit;
}

function format(x) {
    let s = x.toFixed(6); // Reduce decimal digits to 6 (0.123456)
    s = s.replace(".", ""); // Remove the floating point (0.123456 becomes 0123456)

    // Remove leading zeroes for Gerberization
    while (s.startsWith("0")) {
        s = s.substr(1, s.length);
    }

    return s;
}

export function downloadGerber(state) {

    // Some Gerber tips.
    // Include outline in all layers to avoid align issues.
    // Use flashed pads wherever possible.
    // X2 Attributes (meta information):
    // %TF.FileFunction,Soldermask,Top*%
    // Gerber files containing attribute commands (TF, TA, TO, TD) are called Gerber X2 files
    // We want Gerber X2 (at least) out of the box.
    // Set polarity to dark: %LPD*% 
    // Define aperture: %ADD10C,0.010*%
    // Select aperture: D10*
    // End of file: M02*
    
    // Apertures
    // - Standard apertures. They are pre-defined: the circle (C), rectangle (R), obround (O) and
    //   regular polygon (P). See 4.4.
    // - Macro apertures. They are created with the AM (Aperture Macro) command. Any shape
    //   and parametrization can be created. They are identified by their given name. (See 4.4.6).

    // Complex shapes, such as pads that are polygons, not circles anymore:
    // See page 63 in the Gerber Spec.


    const layers = state.pcb.layers;
  
    const expandWire = w => offset2(
      w.shape, 
      w.thickness/2, 
      {
        endType: "etOpenRound", 
        jointType:"jtRound", 
      }
    );
  
    // this is a list of polylines
    const frontCopper = layers["F.Cu"].map( x => {
        if (x.type === "wire") return expandWire(x);
        else return x;
    }).flat();

    const backCopper = layers["B.Cu"].map( x => {
        if (x.type === "wire") return expandWire(x);
        else return x;
    }).flat();
  
    const drill = (layers["drill"] ? layers["drill"] : []).flat().map( x => {
  
      const getCenter = (pts) => {
        let totalX = 0;
        let totalY = 0;
        pts.forEach(pt => {
          totalX += pt[0];
          totalY += pt[1];
        })
  
        return [ totalX/pts.length, totalY/pts.length ];
      }
  
      const getDistance = (pt0, pt1) => Math.sqrt((pt1[0] - pt0[0])**2+(pt1[1] - pt0[1])**2);
  
      const center = getCenter(x);
      const dist = Math.round(1000*x.reduce((acc, cur) => acc + getDistance(center, cur), 0)/x.length)/1000;
  
      return {
        center, 
        dist
      };
    });
  
    const interior = layers["interior"].map( x => {
      return x;
    }).flat();;
  
    console.log({
      drill,
      frontCopper,
      backCopper,
      interior
    })
  
    const makeFile = (layer) => {
      let str = ''
      
      // Add a header comment at the top to indicate the generator.
      str += "G04 File generated by SVG-PCB*\n";

      // Add date and time of generation.
      const dateTime = new Date().toISOString();
      str += "G04 " + dateTime + " (ISO date)*\n";

      // It is recommended to use metric. Imperial is there for historic reasons only 
      // and will be deprecated at a future date. Source: Gerber Spec. p. 46.
      str += "%MOMM*%\n"

      // 4 integer digits and 6 decimal digits, borrowed from KiCad gerber export.
      str += "%FSLAX46Y46*%\n"
      
      str += "%LPD*%\n" // layer dark
      str += "G01*\n" // linear interpolation
  
      const strs = layer.map( pts => {
        let ptsString = pts.reduce((acc, cur, i) => `${acc}X${format( toMM(cur[0]) )}Y${format( toMM(cur[1]) )}D0${i === 0 ? 2 : 1}*\n`, "G36*\n")
        ptsString += "G37*\n";
  
        return ptsString;
      });
  
      str += strs.join("");
      
      // End of Gerber file
      str += "M02*";
  
      return str;
    }
  
    // What format drills here? One could use Gerber for drills too.
    const makeFileDrill = (drills) => {
      const tools = {};
      drills.forEach( ({ dist, center }) => {
        if (dist in tools) {
          tools[dist].push(center);
        } else {
          tools[dist] = [ center ];
        }
      })
  
      let str = "";
      str += "M48\n" // start of header
      str += "INCH,LZ\n" // inch units with leading zeros
      str += "VER,1\n" // version 1
      str += "FMAT,2\n" // format 2
      for (const tool in tools) {
        str += 'T'+ tool + 'C'+ tool + "\n"; // +'C'+tool+"\n" // define tools
      }
      str += "M95\n" // end of header
      str += "G05\n" // drill mode
      for (const tool in tools) {
         str += 'T'+tool+'\n' // tool selection
         for (var i = 0; i < tools[tool].length; i++) {
            const hole = tools[tool][i];
            str += 'X'+format(hole[0])+'Y'+format(hole[1])+'\n'
         }
      }
      
      str += "M30\n" // end of program
  
      return str;
    }

    var zip = new JSZip();
    global_state.downloadGerberOptions.layers.forEach((val, key) => {
        if (!val) return;
        
        switch (key) {
            case "F.Cu":
                zip.file(`${state.name === "" ? "anon" : state.name}-F_Cu.gbr`, makeFile(frontCopper));
                break;
            case "B.Cu":
                zip.file(`${state.name === "" ? "anon" : state.name}-B_Cu.gbr`, makeFile(backCopper));
                break;
            case "F.Mask":
                break;
            case "B.Mask":
                break;
            case "F.Silkscreen":
                break;
            case "B.Silkscreen":
                break;
            case "Edge.Cuts":
                zip.file(`${state.name === "" ? "anon" : state.name}-Edge_Cuts.gbr`, makeFile(interior));
                break;
            case "Drills":
                zip.file(`${state.name === "" ? "anon" : state.name}-Drill.xln`, makeFileDrill(drill));
                break;
        }
    });
    
    zip
      .generateAsync({ type:"blob" })
      .then((content) => {
          // see FileSaver.js
          saveAs(content, `${state.name === "" ? "anon" : state.name}-gerber.zip`);
      });
  
    // downloadText(`${state.name === "" ? "anon" : state.name}-F_Cu.gbr`, str);
  }